## Array
- 메모리 상 연속한 구간 잡아야 해서 할당에 제약
- Cache hit rate 높음

## LinkedList
- k번째 원소 확인/변경: O(k)
- 메모리 상 연속하지 않아 할당이 쉬움
- Cache hit rate 낮음

**erase(it)**: 현재 iterator 제거 후 다음 iterator 반환
    - it = erase(it) 형태로 써야 안전하다 !!
    - erase(prev(it)): 전 원소 제거(backspace)
    - erase(next(it)): 다음 원소 제거
**insert(it, value)**: 현재 iterator 왼쪽에 value 삽입

## Array와 LinkedList
둘 다 선형 자료구조 이다. 둘의 차이를 알아두자.
|                          | 배열  | 연결리스트 |
| k번째 원소 접근           | O(1)  | O(k)      |
| 임의 위치에 원소 추가/제거 | O(N)  | O(1)      |
| 메모리 상의 배치          | 연속  | 불연속     |
| Overhead                 | -    | O(N)       |

Overhead는 배열은 굳이 따지면 길이를 저장하겠지만
연결리스트는 전 또는 후 pointer를 계속 저장해야 해서
overhead가 발생한다.

## Map vs Unordered Map

1. 내부 구현 차이
- Map: 레드-블랙 트리(균형 이진 탐색 트리)
    - 범위 기반 탐색이 필요하다면 사용
- UnorderedMap: 해시 테이블
    - 빠른 조회가 필요할 때 사용

2. 정렬
- Map: 키 기준 자동 정렬
- UnorderedMap: 정렬 x

3. 시간 복잡도
Search, Insert, Delete에 대해
- Map: O(log N)
- UnorderedMap: O(1) ~ O(N)

#### 형변환
- string to int
    - sstream 추가.
    string s = "123";
    stringstream ss(s);
- int to string
    - string 추가
    string str = to_string(num);


#### 기타
- 큰 숫자를 다룰 때는 string으로 다루는 것도 방법


## Deque

앞 뒤로 넣고 빼는 자료구조.
대표적으로 push_front(), push_back(), pop_front(), pop_back() 여기에 추가로 insert도 존재

**Dequq와 Vector의 차이?**

Vector는 연속적인 메모리 공간에 저장

- 장점: 개별 원소 접근 빠름, 끝 삽입/제거 빠름
- 단점: 처음~중간 삽입, 제거 비용 큼, 확장 비용 큼
    - 메모리 상의 시퀀스를 유지하려는 특성
    - 공간이 부족하면 해당 길이를 수용할 수 있는 새로운 메모리가 필요

Deque는 vector와 유사하나 다름.
임의 접근이 가능하다(다만 벡터보다 느림)

- 장점: 앞, 뒤 삽입/제거 빠름
- 단점: 연속적인 메모리 공간이 아니므로 원소들간 포인터 연산이 불가능

List == Linked List

- 장점: 어느 위치에나 삽입/제거 빠름
- 단점: index를 통한 임의 접근 불가




Deque는 데이터가 메모리 상에 연속적으로 있지 않음