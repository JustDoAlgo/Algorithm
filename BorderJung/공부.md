## Array
- 메모리 상 연속한 구간 잡아야 해서 할당에 제약
- Cache hit rate 높음

## LinkedList
- k번째 원소 확인/변경: O(k)
- 메모리 상 연속하지 않아 할당이 쉬움
- Cache hit rate 낮음

**erase(it)**: 현재 iterator 제거 후 다음 iterator 반환
    - it = erase(it) 형태로 써야 안전하다 !!
    - erase(prev(it)): 전 원소 제거(backspace)
    - erase(next(it)): 다음 원소 제거
**insert(it, value)**: 현재 iterator 왼쪽에 value 삽입

## Array와 LinkedList
둘 다 선형 자료구조 이다. 둘의 차이를 알아두자.
|                          | 배열  | 연결리스트 |
| k번째 원소 접근           | O(1)  | O(k)      |
| 임의 위치에 원소 추가/제거 | O(N)  | O(1)      |
| 메모리 상의 배치          | 연속  | 불연속     |
| Overhead                 | -    | O(N)       |

Overhead는 배열은 굳이 따지면 길이를 저장하겠지만
연결리스트는 전 또는 후 pointer를 계속 저장해야 해서
overhead가 발생한다.


## Map vs Unordered Map

1. 내부 구현 차이
- Map: 레드-블랙 트리(균형 이진 탐색 트리)
    - 범위 기반 탐색이 필요하다면 사용
- UnorderedMap: 해시 테이블
    - 빠른 조회가 필요할 때 사용

2. 정렬
- Map: 키 기준 자동 정렬
- UnorderedMap: 정렬 x

3. 시간 복잡도
Search, Insert, Delete에 대해
- Map: O(log N)
- UnorderedMap: O(1) ~ O(N)

#### 형변환
- string to int
    - sstream 추가.
    string s = "123";
    stringstream ss(s);
- int to string
    - string 추가
    string str = to_string(num);


#### 기타
- 큰 숫자를 다룰 때는 string으로 다루는 것도 방법

